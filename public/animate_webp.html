<!DOCTYPE html>
<html>
<head>
    <style>
        body { margin: 0; background: #000; }
        .scroll-container { height: 500vh; } /* Controls scroll speed */
        .sticky-wrapper {
            position: sticky;
            top: 0;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>
<div class="content" style="height: 100vh; background: white; display: flex; align-items: center; justify-content: center;">
  <h1>Scroll to see the animation</h1>
</div>
<div class="scroll-container">
    <div class="sticky-wrapper">
        <canvas id="scroll-canvas"></canvas>
    </div>
</div>
<div class="content" style="height: 100vh; background: white; display: flex; align-items: center; justify-content: center;">
  <h1>End of Experience</h1>
</div>

<script>
    const canvas = document.getElementById("scroll-canvas");
    const context = canvas.getContext("2d");
    const stickyWrapper = document.querySelector(".sticky-wrapper");
    const scrollContainer = document.querySelector(".scroll-container");

    // CONFIGURATION
    const frameCount = 104; // Total number of WebP frames
    const scrollSpeed = 1.5; // 1 = normal, >1 = faster, <1 = slower
    const baseScrollHeightVh = 500; // matches the CSS default
    const currentFrame = index => (
        `/images/pepper_animate/frame_${(index + 1).toString().padStart(4, '0').slice(-4)}.webp`

    );

    // If you speed up, reduce the scroll section height so the animation still ends at the bottom.
    scrollContainer.style.height = `${baseScrollHeightVh / scrollSpeed}vh`;

    // Preload a small set first, then progressively load the rest.
    const images = new Array(frameCount);
    const eagerFrames = Math.min(24, frameCount);
    const maxConcurrentLoads = 4;
    const backgroundQueue = [];

    const loadImage = (index) => {
        if (images[index]) return images[index];
        const img = new Image();
        img.src = currentFrame(index);
        images[index] = img;
        return img;
    };

    const eagerIndices = new Set();
    if (eagerFrames === frameCount) {
        for (let i = 0; i < frameCount; i++) eagerIndices.add(i);
    } else {
        const step = (frameCount - 1) / (eagerFrames - 1);
        for (let i = 0; i < eagerFrames; i++) {
            eagerIndices.add(Math.round(i * step));
        }
    }

    for (const index of eagerIndices) {
        loadImage(index);
    }

    for (let i = 0; i < frameCount; i++) {
        if (!eagerIndices.has(i)) backgroundQueue.push(i);
    }

    let inFlightLoads = 0;
    const scheduleBackgroundLoad = () => {
        if (inFlightLoads >= maxConcurrentLoads) return;
        const index = backgroundQueue.shift();
        if (index === undefined) return;
        inFlightLoads += 1;
        const img = loadImage(index);
        const done = () => {
            inFlightLoads -= 1;
            scheduleBackgroundLoad();
        };
        img.addEventListener("load", done, { once: true });
        img.addEventListener("error", done, { once: true });
        scheduleBackgroundLoad();
    };

    const defer = window.requestIdleCallback
        ? window.requestIdleCallback
        : (cb) => window.setTimeout(cb, 0);
    defer(() => {
        for (let i = 0; i < maxConcurrentLoads; i++) {
            scheduleBackgroundLoad();
        }
    });

    // Set canvas dimensions to viewport width and height
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const clamp01 = (n) => Math.max(0, Math.min(1, n));

    const getScrollProgressInSection = () => {
        const scrollY = window.pageYOffset;
        const start = scrollContainer.offsetTop;
        // Finish when the sticky section ends (bottom reaches viewport bottom).
        const stickyRange = Math.max(0, scrollContainer.offsetHeight - window.innerHeight);
        const end = start + stickyRange;
        if (end <= start) return 0;
        return clamp01((scrollY - start) / (end - start));
    };

    const drawFrame = (index) => {
        const img = loadImage(index);
        if (!img) return;

        if (img.complete && img.naturalWidth > 0) {
            context.clearRect(0, 0, canvas.width, canvas.height);
            // Contain the canvas like CSS object-fit: contain
            const cw = canvas.width;
            const ch = canvas.height;
            const iw = img.naturalWidth;
            const ih = img.naturalHeight;
            const scale = Math.min(cw / iw, ch / ih);
            const dw = iw * scale;
            const dh = ih * scale;
            const dx = (cw - dw) / 2;
            const dy = (ch - dh) / 2;
            context.drawImage(img, dx, dy, dw, dh);
            return;
        }

        img.addEventListener(
            "load",
            () => {
                if (isActive && index === lastRequestedFrame) {
                    drawFrame(index);
                }
            },
            { once: true }
        );
    };

    let isActive = false;
    let hasActivated = false;
    let rafId = null;
    let lastRequestedFrame = 0;

    const render = () => {
        if (!isActive) return;

        const progress = getScrollProgressInSection();
        const frameIndex = Math.min(frameCount - 1, Math.floor(progress * frameCount));
        lastRequestedFrame = frameIndex;
        drawFrame(frameIndex);
    };

    const onScroll = () => {
        if (!isActive) return;
        if (rafId !== null) return;
        rafId = window.requestAnimationFrame(() => {
            rafId = null;
            render();
        });
    };

    // Always show first frame initially (as a "poster")
    if (images[0].complete) {
        drawFrame(0);
    } else {
        images[0].addEventListener("load", () => drawFrame(0), { once: true });
    }

    // Start "animation" only when the canvas is fully in view
    const observer = new IntersectionObserver(
        (entries) => {
            for (const entry of entries) {
                if (entry.target !== stickyWrapper) continue;
                const rect = entry.boundingClientRect;
                const fullyVisible = rect.top >= -1 && rect.bottom <= (window.innerHeight + 1);

                if (fullyVisible) {
                    hasActivated = true;
                    isActive = true;
                    render();
                } else {
                    // After activation, keep animating while any part is visible.
                    isActive = hasActivated && entry.isIntersecting;
                    // Before first activation, keep showing frame 1 even if page scrolls.
                    if (!hasActivated) drawFrame(0);
                }
            }
        },
        { threshold: [0, 1] }
    );
    observer.observe(stickyWrapper);

    window.addEventListener("scroll", onScroll, { passive: true });
    window.addEventListener("resize", () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        if (isActive) render();
    });
</script>

</body>
</html>

