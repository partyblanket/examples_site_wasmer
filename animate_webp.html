<!DOCTYPE html>
<html>
<head>
    <style>
        body { margin: 0; background: #000; }
        .scroll-container { height: 500vh; } /* Controls scroll speed */
        .sticky-wrapper {
            position: sticky;
            top: 0;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>
<div class="content" style="height: 100vh; background: white; display: flex; align-items: center; justify-content: center;">
  <h1>Scroll to see the animation</h1>
</div>
<div class="scroll-container">
    <div class="sticky-wrapper">
        <canvas id="scroll-canvas"></canvas>
    </div>
</div>
<div class="content" style="height: 100vh; background: white; display: flex; align-items: center; justify-content: center;">
  <h1>End of Experience</h1>
</div>

<script>
    const canvas = document.getElementById("scroll-canvas");
    const context = canvas.getContext("2d");
    const stickyWrapper = document.querySelector(".sticky-wrapper");
    const scrollContainer = document.querySelector(".scroll-container");

    // CONFIGURATION
    const frameCount = 45; // Total number of WebP frames
    const currentFrame = index => (
        `https://raw.githubusercontent.com/olivier3lanc/Scroll-Frames/master/img/phone/frame-${index + 1}.webp`
    );

    // Preload images into an array
    const images = [];
    for (let i = 0; i < frameCount; i++) {
        const img = new Image();
        img.src = currentFrame(i);
        images.push(img);
    }

    // Set canvas dimensions
    canvas.width = 1920; 
    canvas.height = 1080;

    const clamp01 = (n) => Math.max(0, Math.min(1, n));

    const getScrollProgressInSection = () => {
        const scrollY = window.pageYOffset;
        const start = scrollContainer.offsetTop;
        // Use the full scroll-container range (including the un-sticking tail)
        // so the animation doesn't finish before you reach the end of the section.
        const end = start + scrollContainer.offsetHeight;
        if (end <= start) return 0;
        return clamp01((scrollY - start) / (end - start));
    };

    const drawFrame = (index) => {
        const img = images[index];
        if (!img) return;

        if (img.complete && img.naturalWidth > 0) {
            context.clearRect(0, 0, canvas.width, canvas.height);
            // Center the image in the canvas (no scaling)
            const cw = canvas.width;
            const ch = canvas.height;
            const iw = img.naturalWidth;
            const ih = img.naturalHeight;
            const dx = (cw - iw) / 2;
            const dy = (ch - ih) / 2;
            context.drawImage(img, dx, dy);
            return;
        }

        img.addEventListener("load", () => drawFrame(index), { once: true });
    };

    let isActive = false;
    let hasActivated = false;
    let rafId = null;

    const render = () => {
        if (!isActive) return;

        const progress = getScrollProgressInSection();
        const frameIndex = Math.min(frameCount - 1, Math.floor(progress * frameCount));
        drawFrame(frameIndex);
    };

    const onScroll = () => {
        if (!isActive) return;
        if (rafId !== null) return;
        rafId = window.requestAnimationFrame(() => {
            rafId = null;
            render();
        });
    };

    // Always show first frame initially (as a "poster")
    if (images[0].complete) {
        drawFrame(0);
    } else {
        images[0].addEventListener("load", () => drawFrame(0), { once: true });
    }

    // Start "animation" only when the canvas is fully in view
    const observer = new IntersectionObserver(
        (entries) => {
            for (const entry of entries) {
                if (entry.target !== stickyWrapper) continue;
                const rect = entry.boundingClientRect;
                const fullyVisible = rect.top >= -1 && rect.bottom <= (window.innerHeight + 1);

                if (fullyVisible) {
                    hasActivated = true;
                    isActive = true;
                    render();
                } else {
                    // After activation, keep animating while any part is visible.
                    isActive = hasActivated && entry.isIntersecting;
                    // Before first activation, keep showing frame 1 even if page scrolls.
                    if (!hasActivated) drawFrame(0);
                }
            }
        },
        { threshold: [0, 1] }
    );
    observer.observe(stickyWrapper);

    window.addEventListener("scroll", onScroll, { passive: true });
    window.addEventListener("resize", () => {
        if (isActive) render();
    });
</script>

</body>
</html>
